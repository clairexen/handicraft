(set-logic ALL)

(declare-datatype |counter-init| ((|counter-mk-init|
  (|counter-init-count| (_ BitVec 8))
)))

(declare-datatype |counter-input| ((|counter-mk-input|
  (|counter-input-reset| Bool)
  (|counter-input-up| Bool)
)))

(declare-datatype |counter-state| ((|counter-mk-state|
  (|counter-state-count| (_ BitVec 8))
)))

(declare-datatype |counter-values| ((|counter-mk-values|
  (|counter-values-reset| Bool)
  (|counter-values-up| Bool)
  (|counter-values-count| (_ BitVec 8))
  (|counter-values-t1| (_ BitVec 8))
  (|counter-values-t2| (_ BitVec 8))
  (|counter-values-t3| (_ BitVec 8))
)))

(define-fun |counter-first| ((init |counter-init|)) counter-state (|counter-mk-state|
  (|counter-init-count| init)
))

(define-fun |counter-next| ((values |counter-values|)) counter-state (|counter-mk-state|
  (|counter-values-t3| values) ; count
))

; note the use of cascaded let statement here, because the SMT-LIB (let ...) statement works
; in a "parallel" fashion and does not support "sequential let". Alternatively we might want
; to define inidividual |counter-eval-net-...| functions above and just call then all here
; directly in |counter-mk-values| without the need for a local let binder in this function
(define-fun |counter-eval| ((input |counter-input|) (state |counter-state|)) counter-values
  (let (
    (|net-reset| (|counter-input-reset| input))
    (|net-up| (|counter-input-up| input))
    (|net-count| (|counter-state-count| state))
  ) (let (
    (|net-t1| (bvadd |net-count| #b00000001))
  ) (let (
    (|net-t2| (ite |net-up| |net-t1| |net-count|))
  ) (let (
    (|net-t3| (ite |net-reset| #b00000000 |net-t2|))
  ) (|counter-mk-values|
    |net-reset|
    |net-up|
    |net-count|
    |net-t1|
    |net-t2|
    |net-t3|
))))))

(declare-const init |counter-init|)
(declare-const input_0 |counter-input|)
(declare-const input_1 |counter-input|)
(declare-const input_2 |counter-input|)
(declare-const input_3 |counter-input|)
(declare-const input_4 |counter-input|)

(define-fun values_0 () |counter-values| (|counter-eval| input_0 (! (|counter-first| init) :named state_0)))
(define-fun values_1 () |counter-values| (|counter-eval| input_1 (! (|counter-next| values_0) :named state_1)))
(define-fun values_2 () |counter-values| (|counter-eval| input_2 (! (|counter-next| values_1) :named state_2)))
(define-fun values_3 () |counter-values| (|counter-eval| input_3 (! (|counter-next| values_2) :named state_3)))
(define-fun values_4 () |counter-values| (|counter-eval| input_4 (! (|counter-next| values_3) :named state_4)))

(assert (= (|counter-values-count| values_0) #b00000111))
(assert (= (|counter-values-count| values_4) #b00000010))

(check-sat)
(get-model)

(get-value (
  (|counter-values-count| values_0)
  (|counter-values-count| values_1)
  (|counter-values-count| values_2)
  (|counter-values-count| values_3)
  (|counter-values-count| values_4)
))

(get-value (
  (|counter-values-reset| values_0)
  (|counter-values-reset| values_1)
  (|counter-values-reset| values_2)
  (|counter-values-reset| values_3)
  (|counter-values-reset| values_4)
))

(get-value (
  (|counter-values-up| values_0)
  (|counter-values-up| values_1)
  (|counter-values-up| values_2)
  (|counter-values-up| values_3)
  (|counter-values-up| values_4)
))
